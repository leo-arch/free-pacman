#!/usr/bin/env bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#

### DESCRIPTION ###

# Little pacman wrapper to make pacman free-software aware. This script
#+ checks all packages to be installed against Parabola's blacklist,
#+ warns the user if the package is non-free, and then, if the user
#+ accepts, installs the corresponding package. It also includes a
#+ rules file to choose repos on a per package basis (both for
#+ upgrades and new packages installation)

#+ Built-in pacfree options:
#+ [package(s)] (No options amounts to -Syu [PKG(S)])
#+ -f | --check-free (check for non-free installed packages)
#+ -L | --add-libre (Add and enable [libre] repository)
#+ -a | --add-rule (Add new repo rule)
#+ -l | --list-rules (List current rules)
#+ -r | --list-repos (List currently enabled repos)

### TODO list ###
# 1) --ignore and --ignoregroup directives won't work
# 2) Package managers different to pacman and powerpill will most
#+ likely fail (because of having different options)
# 3) Make isfree use the same blacklist filenames as pacfree

### COLORS ###

yellow='\033[1;33m'
green="\033[1;32m"
red="\033[1;31m"
blue="\033[1;34m"
bold='\033[1m'
nc="\033[0m"

### PROGRAM DATA ###

ME="PacFree"
VERSION="0.4.4"
AUTHOR="L. Abramovich"
DATE="Jan 2, 2021"
LICENSE="GPL2"
WEBSITE="https://github.com/leo-arch/pacfree"

### BLACKLISTS ###

BLACKLIST_SOURCE="https://git.parabola.nu/blacklist.git/plain/blacklist.txt"
BLACKLIST_FILE="/tmp/pkgs_blacklist"

BLACKLIST_SOURCE_AUR="https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt"
BLACKLIST_FILE_AUR="/tmp/pkgs_blacklist_aur"

### EXIT CODES ###

EXIT_SUCCESS=0
EXIT_FAILURE=1

### FUNCTIONS ###

function echoerr ()
{
	echo -e "$@" >&2
}

function help ()
{
	local arg="$1"
	case $arg in
		help)

			if [[ $PACMAN != "pacman" ]]; then
				/usr/bin/"$PACMAN" -h
				echo "	${ME,,} {-f --check-free}
	${ME,,} {-l --list-rules}
	${ME,,} {-a --add-rule}	  <rule(s)>
	${ME,,} {-L --add-libre}
	${ME,,} {-r --list-repos} [repo(s)]"
			fi

			echo -e "${ME}, the free-software aware pacman
Usage: ${ME,,} <operation> [...]

Operations:
  ${ME,,} {-h --help}
  ${ME,,} {-V --version}
  ${ME,,} {-D --database}   <options> <package(s)>
  ${ME,,} {-F --files}      [options] [package(s)]
  ${ME,,} {-Q --query}      [options] [package(s)]
  ${ME,,} {-R --remove}     [options] <package(s)>
  ${ME,,} {-S --sync}       [options] [package(s)]
  ${ME,,} {-T --deptest}    [options] [package(s)]
  ${ME,,} {-U --upgrade}    [options] <file(s)>

$ME specific operations:
  ${ME,,} [package(s)]
  ${ME,,} {-f --check-free}
  ${ME,,} {-l --list-rules}
  ${ME,,} {-a --add-rule}   <rule(s)>
  ${ME,,} {-L --add-libre}
  ${ME,,} {-r --list-repos} [repo(s)]

Use '${ME,,} {-h --help}' with an operation for available options

If no operation is specified, but only packages, -Syu is assumed

For those users coming from Debian/RedHat based systems, the following \
APT/DNF syntax is recognized (the pacman/${ME,,} equivalent is \
provided in parentheses and is always the recommended way to go):

  install (-Syu)
  install-local (-U)
  remove (-Rns)
  update (-Sy)
  upgrade (-Syu)
  search (-Ss)
  list-installed (-Qe)
  list-installed-native (-Qen)
  list-installed-foreign (-Qem)
  list-installed-deps (-Qd)
  list-updates (sudo pacman -Sy && pacman -Qu)
  list-repos ('pacfree -r' or 'pacman-conf -l' )
  info (-Qi)
  info-remote (-Si)
  list-files (-Ql)
  provides (-Qo)
  provides-remote (-F)
  check (-Qk)
  check-free (-f)
  clean (-Sc)
  clean-all (-Scc)
  download (-Sw)
  help (-h)
  version (-V)
  history (cat /var/log/pacman.log)"
		;;

		checkfree)
			echo -e "List all non-free installed packages
Usage: ${ME,,} {-f --check-free}"
		;;

		addlibre)
			echo -e "Add and enable Parabola's libre repositories to \
pacman database\nUsage: ${ME,,} {-L --add-libre}"
		;;

		addrules)
			echo -e "Add new rules to the rules list
Usage: ${ME,,} {-a --add-rule} rule(s)"
		;;

		listrules)
			echo -e "List currently enabled rules
Usage: ${ME,,} {-l --list-rules}"
		;;

		listrepos)
			echo -e "List currently enabled repositories or check \
repositories specified as further arguments
Usage: ${ME,,} {-r --list-repos} [repo(s)]"
	esac
}

function check_sys_free ()
{
	if [[ $(type -P /usr/bin/isfree) ]]; then
		if [[ $full_blacklist -eq 0 ]]; then
			if [[ $color_ok -eq 1 ]]; then
				/usr/bin/isfree -cna || exit $EXIT_FAILURE
			else
				/usr/bin/isfree -na || exit $EXIT_FAILURE
			fi
		else
			if [[ $color_ok -eq 1 ]]; then
				/usr/bin/isfree -ctna || exit $EXIT_FAILURE
			else
				/usr/bin/isfree -tna || exit $EXIT_FAILURE
			fi
		fi

	else
		local nonfree=0
		local aur=0
		local colorize="--color=always"

		[[ $color_ok -eq 0 ]] && colorize="--color=never"

		for i in $(/usr/bin/pacman -Qq); do

			# Make sure pkg does not come from Parabola repos
			if [[ $(/usr/bin/ls /var/cache/pacman/pkg/"$i"* 2>/dev/null\
			| /usr/bin/grep '.*.par[0-9].*\|.*.parabola[0-9].*\|.*_gnu-[0-9].*') ]]; then
				continue
			fi

			export GREP_COLORS="mt=1;31"
			if /usr/bin/grep "$colorize" "^${i}:" \
			"$BLACKLIST_FILE"; then
				(( nonfree++ ))
			else
				export GREP_COLORS="mt=1;36"
				# Check the AUR blacklist as well
				if /usr/bin/grep "$colorize" "^${i}:" \
				"$BLACKLIST_FILE_AUR"; then
					(( nonfree++ ))
					aur=1
				fi
			fi
		done

		unset GREP_COLORS

		if [[ nonfree -eq 0 ]]; then
			echo -e "\n${green}[+]$nc No non-free/libre package found. RMS smiles!"
		else
			echo -e "\n${red}[-]$nc $nonfree non-free/libre packages found"
		fi

		if [[ $aur -eq 1 ]]; then
			echo -e "\n${bold}NOTE${nc}: Packages highlighted in cyan come from the AUR"
		fi
	fi
}

function add_libre_repos ()
{
	local missing_repo=0
	local libre_repos=()

	for x in libre libre-multilib pcr kernels cross nonprism; do
		if [[ $(/usr/bin/pacman-conf -r "$x" 2>/dev/null) ]]; then
			echo -e "${green}[+]$nc The [${x}] repository is already \
enabled"
		else
			answer="."

			while [[ $answer != "Y" && $answer != "y" \
			&& $answer != "N" && $answer != "n" && $answer != "" ]]; do
				read -rp " Add [${x}]? [y/N] " answer
			done

			case $answer in
				y|Y)
					(( missing_repo++ ))
					libre_repos[${#libre_repos[*]}]="$x"
				;;
				""|n|N) continue ;;
			esac
		fi
	done

	[[ $missing_repo -eq 0 ]] && return

	/usr/bin/sudo /usr/bin/true

	local keyring_url="https://www.parabola.nu/packages/libre/x86_64/parabola-keyring/download"
	local mirrorlist_url="https://mirror.fsf.org/parabola/mirrorlist.txt"

	if ! [[ $(/usr/bin/pacman -Q parabola-keyring) ]]; then
		local RFSL_OK=0
		if [[ $(/usr/bin/grep "^RemoteFileSigLevel = Never$" /etc/pacman.conf) ]]; then
			RFSL_OK=1
		fi

		if [[ RFSL_OK -eq 0 ]]; then
			echo -e "${blue}::$nc$bold Setting RemoteFileSigLevel to Never...$nc "
			/usr/bin/sudo /usr/bin/sed -i \
			'/RemoteFileSigLevel/a RemoteFileSigLevel = Never' \
			/etc/pacman.conf
		fi

		echo -e "${blue}::$nc$bold Installing parabola-kerying...$nc "
		/usr/bin/sudo /usr/bin/pacman -U "$keyring_url"

		if [[ RFSL_OK -eq 0 ]]; then
			echo -e "${blue}::$nc$bold Reverting changes made to RemoteFileSigLevel...$nc "
			/usr/bin/sudo /usr/bin/sed -i '/RemoteFileSigLevel = Never/d' \
			/etc/pacman.conf
		fi
	fi

	if ! [[ -f /etc/pacman.d/parabola_mirrorlist ]]; then
		echo -e "${blue}::$nc$bold Downloading Parabola's mirrorlist...$nc "
		/usr/bin/sudo /usr/bin/curl -so /etc/pacman.d/parabola_mirrorlist \
		"$mirrorlist_url"
	fi

	for x in ${libre_repos[*]}; do

		if ! [[ $(/usr/bin/pacman-conf -r "$x" 2>/dev/null) ]]; then
			echo -e "${blue}::$nc$bold Adding [${x}] repository to /etc/pacman.conf...$nc "
			echo -e "\n[${x}]\nInclude = /etc/pacman.d/parabola_mirrorlist" \
			| /usr/bin/sudo /usr/bin/tee -a /etc/pacman.conf 1>/dev/null
		fi

	done

	echo -e "${blue}::$nc$bold Updating pacman database...$nc "

	/usr/bin/sudo /usr/bin/pacman -Sy
}

function download_blacklist ()
{
	# If full blacklist is enabled and the current blacklist file is
	#+ not the full version, delete it
	if [[ $full_blacklist -eq 1 ]]; then
		if [[ -f $BLACKLIST_FILE ]]; then
			if ! [[ $(/usr/bin/grep "^pacman:" "$BLACKLIST_FILE") ]]; then
				/usr/bin/rm "$BLACKLIST_FILE"
			fi
		fi

	# If full blacklist is not enabled and the current blacklist file
	#+ is the full version, delete it
	else
		if [[ -f $BLACKLIST_FILE ]]; then
			if [[ $(/usr/bin/grep "^pacman:" "$BLACKLIST_FILE") ]]; then
				/usr/bin/rm "$BLACKLIST_FILE"
			fi
		fi
	fi

	if [[ -f $BLACKLIST_FILE ]]; then

		# If the blacklist file exists and it was last modified one
		#+ day ago or less, do nothing
		[[ $(($(/usr/bin/date "+%s") -  \
		$(/usr/bin/stat -c "%Y" "$BLACKLIST_FILE"))) \
		-le 86400 ]] &&	return

		/usr/bin/rm "$BLACKLIST_FILE" 2>/dev/null
	fi

	echo -ne "${blue}::$nc$bold Downloading packages blacklist... $nc"

	if /usr/bin/curl -s "$BLACKLIST_SOURCE" \
	| /usr/bin/sed 's/  //g' \
	| /usr/bin/sudo -u "$user" /usr/bin/tee /tmp/blacklist_full \
	&> /dev/null; then
		echo -e "${green}OK$nc"

		if [[ $full_blacklist -eq 0 ]]; then

			# Parse the blacklist to remove technical and branding
			#+ nonfree packs
			/usr/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" \
			/tmp/blacklist_full | sudo -u "$user" tee "$BLACKLIST_FILE" \
			&>/dev/null

			/usr/bin/rm /tmp/blacklist_full 2>/dev/null
		else
			/usr/bin/sudo -u "$user" /usr/bin/cp \
			/tmp/blacklist_full "$BLACKLIST_FILE"

			/usr/bin/rm /tmp/blacklist_full 2>/dev/null
		fi
	else
		echoerr "\n${red}[-]$nc Error: try again"
		exit $EXIT_FAILURE
	fi
}

function download_blacklist_aur ()
{
	if [[ -f $BLACKLIST_FILE_AUR ]]; then

		# If the blacklist file exists and it was last modified one
		#+ day ago or less, do nothing
		[[ $(($(/usr/bin/date "+%s") -  \
		$(/usr/bin/stat -c "%Y" "$BLACKLIST_FILE_AUR"))) \
		-le 86400 ]] &&	return

		/usr/bin/rm "$BLACKLIST_FILE_AUR" 2>/dev/null
	fi

	echo -ne "${blue}::$nc$bold Downloading packages blacklist (AUR)... $nc"

	if /usr/bin/curl -s "$BLACKLIST_SOURCE_AUR" \
	| /usr/bin/sed 's/  //g' \
	| /usr/bin/sudo -u "$user" /usr/bin/tee /tmp/blacklist_full_aur \
	&> /dev/null; then

		echo -e "${green}OK$nc"

		/usr/bin/sudo -u "$user" /usr/bin/cp \
		/tmp/blacklist_full_aur "$BLACKLIST_FILE_AUR"

		/usr/bin/rm /tmp/blacklist_full_aur 2>/dev/null
	else
		echoerr "\n${red}[-]$nc Error: try again"
		exit $EXIT_FAILURE
	fi
}

function check_free ()
{
	[[ ${#PKGS[*]} -eq 0 ]] && return

	local pkgs_counter=${#PKGS[*]}

	echo -e "${blue}::$nc$bold Checking packages against the blacklist... $nc"

	for (( i=0;i<${#PKGS[*]};i++ )); do
		unset repo pkg
		# If repo/pkg get the two values
		if [[ ${PKGS[$i]} == *"/"* ]]; then
			repo=${PKGS[$i]%%/*}
			pkg=${PKGS[$i]##*/}
		else
			pkg=${PKGS[$i]}
		fi

		# If pkg-version, get pkg name
		if [[ $pkg == *">"* || $pkg == *"<"* ]]; then
			case $pkg in
				*">"*) pkg="${pkg%%>*}" ;;
				*"<"*) pkg="${pkg%%<*}" ;;
			esac
		fi

		if [[ -n $repo ]]; then
			case $repo in

				# If $repo is some of the Parabola's repos, skip the
				#+ test, since $pkg is supposed to be free
				'libre'|'libre-multilib'|'kernels'|'pcr'|'cross'\
				|'nonprism'|'libre-testing'|'libre-multilib-testing'\
				|'pcr-testing'|'nonprism-testing')
					continue
				;;

				# If not in Parabola's repos, check it against the
				#+ blacklist
				*) ;;
			esac
		fi

		# Check if $pkg is blacklisted
		blacklisted="$(/usr/bin/grep "^${pkg}:" "$BLACKLIST_FILE" \
		2>/dev/null)"

		# If using some pac-man able to install packages from the
		#+ AUR, like yay or trizen, we need to check the AUR
		#+ blacklist as well
		if [[ $PACMAN != "pacman" && $PACMAN != "powerpill" ]]; then
			if [[ -z $blacklisted ]]; then
				blacklisted="$(/usr/bin/grep "^${pkg}:" \
				"$BLACKLIST_FILE_AUR" 2>/dev/null)"
			fi
		fi

		if [[ -n $blacklisted ]]; then

			# If blacklisted, get alternative pkg
			alternative="$(echo "$blacklisted" | /usr/bin/cut -d":" -f2)"
			echo -e "\n$nc$bold'$pkg'$nc is a ${red}non-free$nc package\
\n$nc${bold}Description${nc}: $blacklisted\
\n$nc${bold}Alternative package${nc}: $([[ $alternative ]] && echo "$alternative" \
	|| echo "none")"

			answer="."
			valid_answers=( "y" "Y" "n" "N" )
			msg=$(echo -e "${blue}::$nc$bold Do you want to install '${PKGS[$i]}' anyway? [y/N]$nc ")

			while [[ ! " ${valid_answers[*]} " =~ " ${answer} " \
			&& $answer != "" ]]; do
				read -rp "$msg" answer
			done

			case $answer in

				""|n|N)
					PKGS[$i]=""
					(( pkgs_counter-- ))
				;;

				y|Y) ;;
			esac

		fi
	done

	# If no pkg left after this check, just exit
	[[ $pkgs_counter -eq 0 ]] && exit $EXIT_SUCCESS

	# If no blacklisted package, $blacklisted will be emtpy
	if [[ -z $blacklisted ]]; then
		echo -e "${green} ->$nc No blacklisted packages found"
	fi
}

function list_rules ()
{
	local rules=( $(/usr/bin/grep -v "^$\|^#" "$RULES_FILE" 2>/dev/null) )
	if [[ ${#rules[*]} -gt 0 ]]; then
		for rule in ${rules[*]}; do
			echo "$rule"
		done
	else
		echo -e "${yellow}[*]$nc No rules found"
	fi
}

function print_version ()
{
	printf "%-23s$ME v%s (%s, by %s)\n%-23sLicense: %s\n%-23sWebsite: %s\n" "" "$VERSION" "$DATE" "$AUTHOR" "" "$LICENSE" "" "$WEBSITE"
	/usr/bin/"$PACMAN" --version || exit $EXIT_FAILURE
}

function check_added_functions ()
{
	case "$2" in

		# Modified version of pacman help (A)
		-h|--help)
			case "$1" in

				-f|--check-free) help "checkfree" ;;

				-L|--add-libre) help "addlibre" ;;

				-a|--add-rules) help "addrules" ;;

				-l|--list-rules) help "listrules" ;;

				-r|--list-repos) help "listrepos" ;;

				*) /usr/bin/"$PACMAN" "$1" --help ;;
			esac

			exit $EXIT_SUCCESS ;;
	esac

	case "$1" in

		# Modified version of pacman help (B)
		""|-h|--help)
			help "help"
			exit $EXIT_SUCCESS
		;;

		-V|--version)
			print_version
			exit $EXIT_SUCCESS
		;;

		# Added functions
		-f|--check-free)
			download_blacklist
			download_blacklist_aur
			check_sys_free
			exit $EXIT_SUCCESS
		;;

		-l|--list-rules)
			list_rules
			exit $EXIT_SUCCESS
		;;

		-a|--add-rules)
			shift
			rules=( "$@" )
			add_rules ${rules[*]}
			exit $EXIT_SUCCESS
		;;

		-L|--add-libre)
			add_libre_repos
			exit $EXIT_SUCCESS
		;;

		-r|--list-repos)
			shift
			list_repos "$@"
			exit $EXIT_SUCCESS
		;;
	esac
}

function list_repos ()
{
	if ! [[ -f /etc/pacman.conf ]]; then
		echoerr "/etc/pacman.conf: No such file or directory"
		exit $EXIT_FAILURE
	fi

	if [[ -n "$1" ]]; then
		for i in "$@"; do
			if [[ $(/usr/bin/grep "^\[${i}\]" /etc/pacman.conf) ]]; then
				echo -e "${green}[+]$nc [${i}]: Found"
			else
				echo -e "${red}[-]$nc [${i}]: Not found"
			fi
		done
	else
		/usr/bin/grep "^\[.*\]" /etc/pacman.conf \
		| /usr/bin/grep -v "options"
	fi
}

function add_rules ()
{
	for rule in "$@"; do
		unset repo
		if [[ $rule == *"/"* ]]; then

			repo=${rule%%/*}

			if ! [[ $(/usr/bin/pacman-conf -r "$repo" \
			2>/dev/null) ]]; then
				echoerr "${red}[-]$nc ${repo}: Repository not found"
				continue
			fi
		else
			echoerr "${red}[-]$nc ${rule}: A repository must be specified"
			continue
		fi

		if ! [[ $(/usr/bin/grep "$rule" "$RULES_FILE")  ]]; then
			echo "$rule" >> "$RULES_FILE"
			echo -e "${green}[+]$nc ${rule}: New rule successfully added"
		else
			echoerr "${red}[-]$nc ${rule}: Rule already exists"
			continue
		fi
	done
}

function print_logs ()
{
	local readonly LOG_FILE="/var/log/pacman.log"

	if [[ -z $1 ]]; then
		if ! /usr/bin/cat "$LOG_FILE"; then
			exit $EXIT_FAILURE
		fi

	else
		local args=( "$@" )
		local pkgs=""
		# Transform "pkg1 pkg2 pkg3" into this string
		#+ "pkg1\|pkg2\|pkg3" to be used by grep
		pkgs="$(echo "${args[*]}" | /usr/bin/sed 's/ /\\|/g')"

		if ! /usr/bin/grep "$pkgs" "$LOG_FILE"; then
			exit $EXIT_FAILURE
		fi
	fi
}

function parse_arguments ()
{
	local sync_index=-1

	# If color is explicitly disabled in command line,
	#+ disable color (overwriting the config file value)
	if [[ ${p[$i]} == *"--color=never"* ]]; then
		yellow=""; green=""; red=""; blue=""; bold=""; nc=""
		pacman_color=""
	fi

	# Process arguments
	for (( i=0;i<${#p[*]};i++ )); do

		case ${p[$i]} in

			# Allow some APT/DNF syntax for users coming from
			#+ Debian/RedHat based systems.
			install) p[$i]="-Syu" ;;
			install-local) p[$i]="-U" ;;
			remove) p[$i]="-Rns" ;;
			update) p[$i]="-Sy" ;;
			upgrade) p[$i]="-Syu" ;;
			search) p[$i]="-Ss" ;;
			list-installed) p[$i]="-Qe" ;;
			list-installed-native) p[$i]="-Qen" ;;
			list-installed-foreign) p[$i]="-Qem" ;;
			list-installed-deps) p[$i]="-Qd" ;;
			info) p[$i]="-Qi" ;;
			info-remote) p[$i]="-Si" ;;
			list-files) p[$i]="-Ql" ;;
			provides) p[$i]="-Qo" ;;
			provides-remote) p[$i]="-F" ;;
			check) p[$i]="-Qk" ;;
			clean) p[$i]="-Sc" ;;
			clean-all) p[$i]="-Scc" ;;
			download) p[$i]="-Sw" ;;

			check-free)
				download_blacklist
				download_blacklist_aur
				check_sys_free
				exit $EXIT_SUCCESS
			;;

			list-updates)
				if [[ $(type -P /usr/bin/checkupdates) ]]; then

					echo -e "${blue}::$nc$bold Checking available upgrades... $nc"
					/usr/bin/checkupdates || exit $EXIT_FAILURE
				else
					local options="--color=auto"
					[[ $color_ok -eq 0 ]] && options="--color=never"
					/usr/bin/sudo /usr/bin/pacman "$options" -Sy \
					|| exit $EXIT_FAILURE

					echo -e "${blue}::$nc$bold Available upgrades: $nc"
					/usr/bin/pacman "$options" -Qu \
					|| exit $EXIT_FAILURE
				fi

				exit $EXIT_SUCCESS
			;;

			list-repos)
				list_repos ${p[*]:1}
				exit $EXIT_SUCCESS
			;;
			help)
				help "help"
				exit $EXIT_SUCCESS
			;;
			version)
				print_version
				exit $EXIT_SUCCESS
			;;
			history)
				print_logs ${p[*]:1}
				exit $EXIT_SUCCESS
			;;
		esac

		# Use a second case statement to be able to catch the string
		#+ (possibily) modified in the previous case statement
		case ${p[$i]} in

			# Catch sync, update and sysupgrade options
			--update) do_update=1 ;;
			
			--sysupgrade) do_sysupgrade=1 ;;
			
			"-S"*)
				sync_value=${p[$i]}
				sync_index=$i
				[[ $sync_value == *'y'* ]] && do_update=1
				[[ $sync_value == *'u'* ]] && do_sysupgrade=1
			;;

			--sync)
				sync_value="--sync"
				sync_index=$i
			;;

			# If not a supported function, warn and exit
			--ignore|--ignoregroup)
				echoerr "${ME,,}: The --ignore and --ignoregroup \
directives are not supported. You still can use pacman configuration \
file instead."
				exit $EXIT_FAILURE
			;;
		esac

	done

	if [[ -z $sync_value ]]; then
		no_install=1

	# Check non-install SHORT suboptions (c,g,h,i,l,s,w,p) for --sync.
	# None of these sync suboptions are intended for software
	#+ installation. So, if some of them is found in the sync string,
	#+ set $no_install to 1, so that check_free() and check_rules(),
	#+ only valid for package installation, won't be executed.
	#+ Drawback: This might break things if $PACMAN is not pacman or
	#+ powerpill.
	elif [[ $sync_value == "-S"* && $(echo "$sync_value" \
	| /usr/bin/grep "[c,g,h,i,l,s,w,p]")  ]]; then
		no_install=1
	fi

	for (( i=0;i<${#p[*]};i++ )); do

		[[ $i -eq $sync_index ]] && continue

		# Check non-install LONG suboptions for --sync.
		if [[ -n $sync_value ]]; then
			case ${p[$i]} in
				--print|--clean|--groups|--info|--list|--search\
				|--downloadonly|--help) no_install=1 ;;
			esac
		fi

		# Whatever is a valid package name goes to PKGS. Everything
		#+ else goes to OPTS
		if [[ ${p[$i]} == '-'* ]]; then
			OPTS[${#OPTS[*]}]=${p[$i]}
		else
			if valid_pkg_name "${p[$i]}" -eq 0; then
				PKGS[${#PKGS[*]}]=${p[$i]}
			else
				OPTS[${#OPTS[*]}]=${p[$i]}
			fi
		fi

	done
}

function check_rules ()
{
	[[ ${#PKGS[*]} -eq 0 ]] && return

	### LOAD REPO RULES ###

	rules=( $(/usr/bin/grep -v "^$\|^#" "$RULES_FILE" 2>/dev/null) )

	echo -e "${blue}::$nc$bold Checking packages against rules...$nc "

	if [[ ${#rules[*]} -eq 0 ]]; then
		echo -e "$yellow ->$nc No rules defined"
		return
	fi

	RULED_PKGS=()

	### CHECK PKGS AGAINST RULES ###

	for (( i=0;i<${#PKGS[*]};i++ )); do

		unset pkg_name pkg_version

		# If repo was already specified in command line (repo/pkg),
		#+ skip the rules test
		if [[ ${PKGS[$i]} == *"/"* ]]; then
			continue
		fi

		pkg_name=${PKGS[$i]}

		# Check pkg version
		if [[ ${PKGS[$i]} == *"<"* || ${PKGS[$i]} == *">"* ]]; then
			case ${PKGS[$i]} in
				*"<"*)
					pkg_name="${PKGS[$i]%%<*}"
					pkg_version="<${PKGS[$i]##*<}"
				;;
				*">"*)
					pkg_name="${PKGS[$i]%%>*}"
					pkg_version=">${PKGS[$i]##*>}"
				;;
			esac
		fi

		for (( j=0;j<${#rules[*]};j++ )); do
			if [[ $pkg_name == "${rules[$j]##*/}" ]]; then

				if [[ -n $pkg_version ]]; then
					PKGS[$i]="${rules[$j]}$pkg_version"
					RULED_PKGS[${#RULED_PKGS[*]}]="${rules[$j]}$pkg_version"
				else
					PKGS[$i]=${rules[$j]}
					RULED_PKGS[${#RULED_PKGS[*]}]=${rules[$j]}
				fi

				break
			fi
		done
	done

	if [[ ${#RULED_PKGS[*]} -gt 0 ]]; then
		echo -e "${green} ->$nc Ruled packages found:"
		for (( i=0;i<${#RULED_PKGS[*]};i++ )); do
			echo " $((i+1))) ${RULED_PKGS[$i]}"
		done
	else
		echo -e "${green} ->$nc No ruled packages found"
	fi
}

function check_updates ()
{
	# Check the sync value looking for (y,--update) and
	#+ (u,--sysupgrade)

	[[ -z $sync_value ]] && return

	# If update (-Sy*), well, update the database
	if [[ $do_update -eq 1 ]]; then
		
		/usr/bin/pacman $pacman_color ${OPTS[*]} -Sy \
		|| exit $EXIT_FAILURE

		# If -S, remove 'y' from sync options
		if [[ $sync_value =~ ^"-S"[a-z]+$ ]]; then
			local tmp=${sync_value//[y]}
			sync_value="$tmp"
		# If --sync (or -S --opts), remove "--update" from the
		#+ OPTS array
		else
			OPTS=( "${OPTS[*]/--update/}" )
		fi
	fi

	if [[ $do_sysupgrade -eq 0 ]]; then
		# If no sysupgrade and no packages to be installed (-Sy), 
		#+ there is nothing else to do
		if [[ ${#PKGS[*]} -eq 0 ]]; then
			exit $EXIT_SUCCESS
		# If no sysupgrade but there are packages to install
		#+ (-Sy pkgs(s)), return to continue performing checks
		else
			return
		fi
	fi

	# If no update (only upgrade), that is, if -Su, update anyway
	if [[ $do_update -eq 0 ]]; then
		# Get available upgrades (update the database)
		/usr/bin/pacman $pacman_color ${OPTS[*]} -Sy \
		|| exit $EXIT_FAILURE
	fi

	# Remove 'u' from sync options
	if [[ $sync_value =~ ^"-S"[a-z]+$ ]]; then
		tmp="${sync_value//[u]}"
		sync_value="$tmp"
	else
		OPTS=( "${OPTS[*]/--sysupgrade/}" )
	fi

	# Get pkgs to be upgraded
	ups=( $(/usr/bin/pacman -Qu | /usr/bin/grep -v \
	"\[ignored\]" | /usr/bin/awk '{print $1}') )

	# If no upgrades and no packages to be installed, exit
	if [[ ${#ups[*]} -eq 0 ]]; then
		if [[ ${#PKGS[*]} -eq 0 ]]; then
			echo -e "${green}[+]$nc There is nothing to do"
			exit $EXIT_SUCCESS
		else
			if [[ $do_sysupgrade -eq 1 ]]; then
				echo -e "${green} ->$nc$bold There are no available upgrades$nc"
			fi
			return
		fi
	fi

	# At this point, $ups[] is always greater than zero: we have
	#+ upgrades

	# If only upgrading (no PKGS), set the only_upgrade flag to 1,
	#+ so that check_free() won't be executed
	[[ ${#PKGS[*]} -eq 0 ]] && only_upgrade=1

	# Append packages to be upgraded to the PKGS array
	for up in ${ups[*]}; do
		PKGS[${#PKGS[*]}]="$up"
	done

	# List upgrades
	echo -e "${blue}::$nc$bold Available upgrades:$nc "
	/usr/bin/pacman "$pacman_color" -Qu || exit $EXIT_FAILURE
}

function check_config ()
{
	# If pacman is not installed, this program is useless
	if ! [[ $(type -P /usr/bin/pacman) ]]; then
		echoerr "/usr/bin/pacman: Command not found"
		exit $EXIT_FAILURE
	fi

	### GENERATE CONFIG FILES AND DIRECTORIES ###

	[[ $SUDO_USER ]] && user=$SUDO_USER || user=$USER

	if [[ $user == "root" ]]; then
		CONFIG_DIR="/root/.config/${ME,,}"
	else
		CONFIG_DIR="/home/$user/.config/${ME,,}"
	fi

	CONFIG_FILE="$CONFIG_DIR/${ME,,}.conf"

	RULES_FILE="$CONFIG_DIR/rules.conf"

	if ! [[ -d $CONFIG_DIR ]]; then
		/usr/bin/sudo -u "$user" /usr/bin/mkdir -pm 700 "$CONFIG_DIR" \
		|| exit $EXIT_FAILURE
	fi

	if ! [[ -f $CONFIG_FILE ]]; then
		echo -e "# $ME configuration file

# If set to false, remove packages with trademarking and merely
# technical issues from the blacklist
full_blacklist=false

# Define you package manager, say pacman or powerpill or yay
pac_man=pacman

# Colorize output
color=true

# Enable or disable $ME checks for packages. Though disabling both
# checks would make $ME useless, it might be usefull in some cases
check_rules=true
check_free=true
" | /usr/bin/sudo -u "$user" /usr/bin/tee "$CONFIG_FILE"

	/usr/bin/chmod 600 "$CONFIG_FILE"

	fi

	if ! [[ -f $RULES_FILE ]]; then
		echo "# Repository rules for $ME

# Add here repository rules for packages, one per line, in the
# form 'repo/pkg' (blank and commented lines are ommited). Packages
# listed here will always be installed/upgraded from the specified
# repository (disregarding its place in pacman config file).
# Example:
# core/filesystem
# libre/licenses
" | /usr/bin/sudo -u "$user" /usr/bin/tee  "$RULES_FILE"

	/usr/bin/chmod 600 "$RULES_FILE"

	fi

	### READ THE CONFIG FILE ###

	local full_bl_value=$(/usr/bin/grep "^full_blacklist=" \
	"$CONFIG_FILE" | /usr/bin/cut -d"=" -f2)

	case $full_bl_value in
		true) full_blacklist=1 ;;
		false) full_blacklist=0 ;;
		*) full_blacklist=0 ;;
	esac

	PACMAN=$(/usr/bin/grep "^pac_man=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)

	if [[ -z $PACMAN ]]; then
		PACMAN="pacman"
	elif ! [[ $(type -P /usr/bin/"$PACMAN") ]]; then
		echoerr	"${red}[-]$nc ${PACMAN}: Command not found"
		exit $EXIT_FAILURE
	fi

	local color=$(/usr/bin/grep "^color=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)

	case $color in
		true) color_ok=1 ;;
		false) color_ok=0 ;;
		*) color_ok=1 ;;
	esac

	if [[ $color_ok -eq 0 ]]; then
		# Disable color for /usr/bin/pacman as well
		pacman_color="--color=never"

		yellow=""; green=""; red=""; blue=""; bold=""; nc=""
	fi

	local rules_value=$(/usr/bin/grep "^check_rules=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)

	case $rules_value in
		true) rules_ok=1 ;;
		false) rules_ok=0 ;;
		*) rules_ok=1 ;;
	esac

	local free_value=$(/usr/bin/grep "^check_free=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)

	case $free_value in
		true) free_ok=1 ;;
		false) free_ok=0 ;;
		*) free_ok=1 ;;
	esac
}

function valid_pkg_name ()
{
# From the Wiki:
# "Package names can contain only alphanumeric characters and any
#+ of @ . _ + -
#+ Names are not allowed to start with hyphens or dots. All letters
#+ should be lowercase."

	local pkg_name="$1"

	# At most, a package expression could contain 1 slash, like in
	#+ "repo/pkg". If more than one, it's not a valid expression
	local res=${pkg_name//[^\/]}
	[[ ${#res} -gt 1 ]] && return $EXIT_FAILURE

	local tmp=""
	case $pkg_name in 

		# Get pkg name in version expressions: "foo>1.2.3"
		*'<'*)
			tmp="${pkg_name%%<*}"
			pkg_name="$tmp"
		;;

		*'>'*)
			tmp="${pkg_name%%>*}"
			pkg_name="$tmp"
		;;
		
		# No valid package expression ends or starts with a slash. 
		#+ If there is a slash, it should be in the middle, like 
		#+ "repo/pkg"
		'/'*|*'/') return $EXIT_FAILURE ;;
	esac

	# Get pkg name in repo expressions: "repo/pkg"
	if [[ $pkg_name == *'/'* ]]; then
		# If there is a slash in the middle of the string, check
		#+ it is not a filename
		if [[ -e "$pkg_name" ]]; then
			return $EXIT_FAILURE
		# If not a filename, take whatever comes after the slash
		#+ as the package name
		else
			tmp="${pkg_name##*/}"
			pkg_name="$tmp"
		fi
	fi
	
	[[ -z "$pkg_name" ]] && return $EXIT_FAILURE

	# Now perform the checks for package names validity

	case $pkg_name in
		# Exclude strings only valid for --color and --architecture
		#+ options
		auto|i[0-6]86|pentium4|x86_64|any|always|never)
			return $EXIT_FAILURE
		;;

		# If it starts with a hyphen or a dot, it's not a valid
		#+ package name
		'-'*|'.'*) return $EXIT_FAILURE ;;
	esac

	# Exclude valid pkg name chars from pkg_name. If something remains,
	#+ it's not a valid package name
	if [[ $(echo "$pkg_name" \
	| /usr/bin/sed 's/[a-z0-9]\|[,@+-./]//g') ]]; then
		return $EXIT_FAILURE
	else
		return $EXIT_SUCCESS
	fi
}

function main ()
{
	p=( "$@" ) # Command line arguments

	## Internal global variables ##

	PKGS=() # List of packages to operate on
	OPTS=() # Everything that is not a package (except the sync string)
	user="" # User running the program
	sync_value="" # Sync string. Ex: -Syu or --sync
	# Should we install/upgrade some package? If not, check_free()
	#+ and check_rules() won't be executed
	no_install=0
	# If only upgrading, that is, if not installing any extra package,
	#+ we should not run check_free()
	only_upgrade=0
	# Catch "-y,--update" and "-u,--sysupgrade" options
	do_update=0
	do_sysupgrade=0

	## Config file options ##

	# Should we use the complete blacklist or a
	#+ trimmed down version without packages marked as non-free
	#+ merely because of branding and technical issues?
	full_blacklist=0

	color_ok=1 # We colorize output by default
	# The "auto" value for --color makes pacman to enable color only
	#+ when outputting onto a tty (interactively, not scripts)
	pacman_color="--color=auto"

	rules_ok=1 # Should we perform the rules check?
	free_ok=1 # Should we perform the free package check?

	### GET/CREATE CONFIGURATION DIRECTORIES AND FILES ###
	check_config

	### GET OPTIONS, SYNC VALUE, AND PKGS TO BE INSTALLED
	#+ FROM INPUT ###
	# Pkgs to be installed are added to PKGS
	parse_arguments

	### Check for added functions: repo rules stuff, modified help,
	#+ and libre repositories ###
	check_added_functions ${p[*]}

	### DOWNLOAD THE BLACKLIST(S) ###
	download_blacklist
	# If using something like yay or trizen, we need the AUR
	#+ blacklist as well
	if [[ $PACMAN != "pacman" && $PACMAN != "powerpill" ]]; then
		download_blacklist_aur
	fi

	# If no operation is specified, but only package(s), -Syu
	#+ is assumed
	if [[ ${#OPTS[*]} -eq 0 && -z $sync_value ]]; then
		sync_value="-Syu"
		no_install=0
	fi

	# This block is only for my personal configuration. You can
	#+ comment it if you like. However, it won't do anything if
	#+ /tmp/updates doesn't exist. If by chance it exists, this
	#+ block only writes a zero to the file.
	if [[ $sync_value == "-Syu" && -f /tmp/updates ]]; then
		echo "0" | /usr/bin/sudo -u "$user" \
		/usr/bin/tee /tmp/updates &>/dev/null
	fi

	### CHECK FOR UPDATES ###
	# Add pkgs to be upgraded, if any, to PKGS
	check_updates

	# Remove duplicates, just in case
	local tmp=( "$(for i in ${PKGS[*]}; do echo "$i"; done | /usr/bin/sort -u)" )
	PKGS=( ${tmp[*]} )
	unset tmp

	# $no_install was set above, in parse_arguments()
	# $no_install includes both upgrades and new packages
	if [[ $no_install -eq 0 ]]; then
		### CHECK PKGS AGAINST REPO RULES ###
		# If some rule is found for a package, the package name in
		#+ PKGS is replaced by the rule (repo/pkg)
		[[ $rules_ok -eq 1 ]] && check_rules

		### CHECK PACKAGES AGAINST THE BLACKLIST ###
		# Non-free/allowed pkgs are removed from PKGS
		[[ $free_ok -eq 1 && $only_upgrade -eq 0 ]] && check_free
	fi

	### FIRE UP THE PACMAN ###

	if ! /usr/bin/"$PACMAN" $pacman_color ${OPTS[*]} $sync_value \
	${PKGS[*]}; then
		exit $EXIT_FAILURE
	fi

#	echo "/usr/bin/$PACMAN $pacman_color ${OPTS[*]} $sync_value ${PKGS[*]}"
}

### MAIN ###

main "$@"

exit $EXIT_SUCCESS
