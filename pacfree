#!/usr/bin/env bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#

### DESCRIPTION ###

# Pacman wrapper to make pacman free-software aware. This script
#+ checks all packages to be installed against Parabola's blacklist,
#+ warns the user if the package is non-free, and then, if the user
#+ accepts, installs the corresponding package. It also includes a
#+ rules file to choose repos on a per package basis (both for
#+ upgrades and new packages installation)

#+ Built-in pacfree options:
#+ [package(s)] (No options amounts to -Syu [PKG(S)])
#+ -f | --check-free (check for non-free installed packages)
#+ -L | --add-libre (Add and enable [libre] repository)
#+ -a | --add-rule (Add new repo rule)
#+ -l | --list-rules (List current rules)
#+ -r | --list-repos (List currently enabled repos)

### TODO LIST ###
# 1) --ignore and --ignoregroup directives won't work
# 2) Package managers different to pacman and powerpill will most
#+ likely fail (because of having different options)
# 3) Make isfree use the same blacklist filenames as pacfree

### COLORS ###

yellow='\033[1;33m'
green="\033[1;32m"
red="\033[1;31m"
blue="\033[1;34m"
bold='\033[1m'
nc="\033[0m"

### PROGRAM DATA ###

ME="PacFree"
VERSION="0.4.9"
AUTHOR="L. Abramovich"
DATE="Jan 5, 2021"
LICENSE="GPL2+"
WEBSITE="https://github.com/leo-arch/pacfree"

### BLACKLISTS ###

BLACKLIST_SOURCE="https://git.parabola.nu/blacklist.git/plain/blacklist.txt"
BLACKLIST_FILE="/tmp/pkgs_blacklist"

BLACKLIST_SOURCE_AUR="https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt"
BLACKLIST_FILE_AUR="/tmp/pkgs_blacklist_aur"

### EXIT CODES ###

EXIT_SUCCESS=0
EXIT_FAILURE=1


					##########################
					#       FUNCTIONS        #
					##########################

################################

function echoerr ()
{
	echo -e "$@" >&2
}

################################

function help ()
{
	# $arg will be local and readonly
	declare -r arg="$1"

	case $arg in
		help)

			if [[ $PACMAN != "pacman" ]]; then
				/usr/bin/"$PACMAN" -h
			else
				echo -e "${ME}, the free-software aware pacman" \
						"\nUsage: ${ME,,} <operation> [...]\n"

				echo -e "Operations:
    ${ME,,} {-h --help}
    ${ME,,} {-V --version}
    ${ME,,} {-D --database}   <options> <package(s)>
    ${ME,,} {-F --files}      [options] [package(s)]
    ${ME,,} {-Q --query}      [options] [package(s)]
    ${ME,,} {-R --remove}     [options] <package(s)>
    ${ME,,} {-S --sync}       [options] [package(s)]
    ${ME,,} {-T --deptest}    [options] [package(s)]
    ${ME,,} {-U --upgrade}    [options] <file(s)>"

			fi

echo -e "\n$ME specific operations:
    ${ME,,} [package(s)]
    ${ME,,} {-f --check-free} [package(s)]
    ${ME,,} {-l --list-rules}
    ${ME,,} {-a --add-rule}   <rule(s)>
    ${ME,,} {-L --add-libre}
    ${ME,,} {-r --list-repos} [repo(s)]
    ${ME,,} {-u --upgrademe}

Use '${ME,,} {-h --help}' with an operation for available options

If no operation is specified, but only packages, -Syu is assumed

Use --color=never to disable colored output

For those users coming from Debian/RedHat based systems, the following \
APT/DNF syntax is recognized (the pacman/${ME,,} equivalent is \
provided in parentheses and is always the recommended way to go):

    install (-Syu)
    install-local (-U)
    remove (-Rns)
    update/refresh (-Sy)
    upgrade/sysupgrade (-Syu)
    search (-Ss)
    list-installed (-Qe)
    list-installed-native (-Qen)
    list-installed-foreign (-Qem)
    list-installed-deps (-Qd)
    list-updates (sudo pacman -Sy && pacman -Qu)
    list-repos ('pacfree -r' or 'pacman-conf -l' )
    info (-Qi)
    info-remote (-Si)
    list-files (-Ql)
    provides (-Qo)
    provides-remote (-F)
    check (-Qk)
    check-free (pacfree -f)
    clean (-Sc)
    clean-all (-Scc)
    download (-Sw)
    help (-h)
    version (-V)
    history [pkg ...] (grep \"pkg ...\" /var/log/pacman.log)"
		;;

		checkfree)
			echo -e "With no argument, lists all non-free installed" \
					"packages. Else, it checks packages specified as" \
					"further arguments against the blacklists" \
					"\nUsage: ${ME,,} {-f --check-free} [packages(s)]"
		;;

		addlibre)
			echo -e "Add and enable Parabola's libre repositories to" \
					"pacman database\nUsage: ${ME,,} {-L --add-libre}"
		;;

		addrules)
			echo -e "Add new rules to the rules list" \
					"\nUsage: ${ME,,} {-a --add-rule} repo/pkg ..."
		;;

		listrules)
			echo -e "List currently enabled rules" \
					"\nUsage: ${ME,,} {-l --list-rules}"
		;;

		listrepos)
			echo -e "List currently enabled repositories or check" \
					"repositories specified as further arguments" \
					"\nUsage: ${ME,,} {-r --list-repos} [repo(s)]"
		;;

		upgrademe)
			echo -e "Check current upstream version" \
					"\nUsage: ${ME,,} {-u --upgrademe}"
		;;
	esac
}

################################

function check_sys_free ()
{
	if [[ $(type -P /usr/bin/isfree) ]]; then
		if [[ $full_blacklist -eq 0 ]]; then
			if [[ $color_ok -eq 1 ]]; then
				/usr/bin/isfree -cna || exit $EXIT_FAILURE
			else
				/usr/bin/isfree -na || exit $EXIT_FAILURE
			fi
		else
			if [[ $color_ok -eq 1 ]]; then
				/usr/bin/isfree -ctna || exit $EXIT_FAILURE
			else
				/usr/bin/isfree -tna || exit $EXIT_FAILURE
			fi
		fi

	else
		local nonfree=0 aur=0 colorize="--color=always"

		[[ $color_ok -eq 0 ]] && colorize="--color=never"

		for i in $(/usr/bin/pacman -Qq); do

			# Make sure pkg does not come from Parabola repos
			if /usr/bin/ls /var/cache/pacman/pkg/"$i"* 2>/dev/null \
			| /usr/bin/grep -q \
			'.*.par[0-9].*\|.*.parabola[0-9].*\|.*_gnu-[0-9].*'; then
				continue
			fi

			export GREP_COLORS="mt=1;31"
			if /usr/bin/grep "$colorize" "^${i}:" \
			"$BLACKLIST_FILE"; then
				(( nonfree++ ))
			else
				export GREP_COLORS="mt=1;36"
				# Check the AUR blacklist as well
				if /usr/bin/grep "$colorize" "^${i}:" \
				"$BLACKLIST_FILE_AUR"; then
					(( nonfree++ ))
					aur=1
				fi
			fi
		done

		unset GREP_COLORS

		if [[ nonfree -eq 0 ]]; then
			echo -e "\n${green}[+]$nc No non-free/libre packages" \
					"found. RMS smiles!"
		else
			echo -e "\n${red}[-]$nc $nonfree non-free/libre" \
					"packages found"
		fi

		if [[ $aur -eq 1 ]]; then
			echo -e "\n${bold}NOTE${nc}: Packages highlighted in" \
					"cyan come from the AUR"
		fi
	fi
}

################################

function add_libre_repos ()
{
	local missing_repo=0 libre_repos=()

	for x in libre libre-multilib pcr kernels cross nonprism; do
		if [[ $(/usr/bin/pacman-conf -r "$x" 2>/dev/null) ]]; then
			echo -e "${green}[+]$nc The [${x}] repository is" \
					"already enabled"
		else
			answer="."

			while ! [[ $answer =~ ^(y|Y|n|N|)$ ]]; do
				read -rp " Add [${x}]? [y/N] " answer
			done

			case $answer in
				y|Y)
					(( missing_repo++ ))
					libre_repos[${#libre_repos[*]}]="$x"
				;;
				""|n|N) continue ;;
			esac
		fi
	done

	[[ $missing_repo -eq 0 ]] && return

	/usr/bin/sudo /usr/bin/true

	local keyring_url="https://www.parabola.nu/packages/libre/x86_64/parabola-keyring/download"
	local mirrorlist_url="https://mirror.fsf.org/parabola/mirrorlist.txt"

	if ! [[ $(/usr/bin/pacman -Q parabola-keyring) ]]; then
		local RFSL_OK=0
		if /usr/bin/grep -q "^RemoteFileSigLevel = Never$" \
		/etc/pacman.conf; then
			RFSL_OK=1
		fi

		if [[ RFSL_OK -eq 0 ]]; then
			echo -e "${blue}::$nc$bold Setting RemoteFileSigLevel" \
					"to Never...$nc "
			/usr/bin/sudo /usr/bin/sed -i \
			'/RemoteFileSigLevel/a RemoteFileSigLevel = Never' \
			/etc/pacman.conf || exit $EXIT_FAILURE
		fi

		echo -e "${blue}::$nc$bold Installing parabola-kerying...$nc "
		/usr/bin/sudo /usr/bin/pacman -U "$keyring_url" \
		|| exit $EXIT_FAILURE

		if [[ RFSL_OK -eq 0 ]]; then
			echo -e "${blue}::$nc$bold Reverting changes made to" \
					"RemoteFileSigLevel...$nc "
			/usr/bin/sudo /usr/bin/sed -i '/RemoteFileSigLevel = Never/d' \
			/etc/pacman.conf || exit $EXIT_FAILURE
		fi
	fi

	if ! [[ -f /etc/pacman.d/parabola_mirrorlist ]]; then
		echo -e "${blue}::$nc$bold Downloading Parabola's" \
				"mirrorlist...$nc "
		/usr/bin/sudo /usr/bin/curl -so \
		/etc/pacman.d/parabola_mirrorlist "$mirrorlist_url" \
		|| exit $EXIT_FAILURE
	fi

	for x in ${libre_repos[*]}; do

		if ! [[ $(/usr/bin/pacman-conf -r "$x" 2>/dev/null) ]]; then
			echo -e "${blue}::$nc$bold Adding [${x}] repository" \
					"to /etc/pacman.conf...$nc "

			echo -e "\n[${x}]\nInclude =" \
					"/etc/pacman.d/parabola_mirrorlist" \
					| /usr/bin/sudo /usr/bin/tee -a /etc/pacman.conf \
					1>/dev/null || exit $EXIT_FAILURE
		fi

	done

	echo -e "${blue}::$nc$bold Updating pacman database...$nc "

	/usr/bin/sudo /usr/bin/pacman -Sy || exit $EXIT_FAILURE
}

################################

function download_blacklist ()
{
	# If full blacklist is enabled and the current blacklist file is
	#+ not the full version, delete it
	if [[ $full_blacklist -eq 1 ]]; then
		if [[ -f $BLACKLIST_FILE ]]; then
			if ! /usr/bin/grep -q "^pacman:" "$BLACKLIST_FILE"; then
				/usr/bin/rm "$BLACKLIST_FILE"
			fi
		fi

	# If full blacklist is not enabled and the current blacklist file
	#+ is the full version, delete it
	else
		if [[ -f $BLACKLIST_FILE ]]; then
			if /usr/bin/grep -q "^pacman:" "$BLACKLIST_FILE"; then
				/usr/bin/rm "$BLACKLIST_FILE"
			fi
		fi
	fi

	if [[ -f $BLACKLIST_FILE ]]; then
		# If the blacklist file exists and it was last modified one
		#+ day ago or less, do nothing
		[[ $(($(/usr/bin/date "+%s") -  \
		$(/usr/bin/stat -c "%Y" "$BLACKLIST_FILE"))) \
		-le 86400 ]] &&	return
	fi

	echo -ne "${blue}::$nc$bold Downloading packages blacklist... $nc"

	if /usr/bin/curl -s "$BLACKLIST_SOURCE" \
	| /usr/bin/sed 's/  //g' \
	| /usr/bin/sudo -u "$user" /usr/bin/tee /tmp/blacklist_full \
	1> /dev/null; then
		echo -e "${green}OK$nc"

		if [[ $full_blacklist -eq 0 ]]; then

			# Parse the blacklist to remove technical and branding
			#+ nonfree packs
			/usr/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" \
			/tmp/blacklist_full | sudo -u "$user" \
			tee "$BLACKLIST_FILE" 1>/dev/null \
			|| exit $EXIT_FAILURE

			/usr/bin/rm /tmp/blacklist_full 2>/dev/null
		else
			/usr/bin/sudo -u "$user" /usr/bin/cp \
			/tmp/blacklist_full "$BLACKLIST_FILE" \
			|| exit $EXIT_FAILURE

			/usr/bin/rm /tmp/blacklist_full 2>/dev/null
		fi
	else
#		echoerr "${ME,,}: Error downloading file"
		exit $EXIT_FAILURE
	fi
}

################################

function download_blacklist_aur ()
{
	if [[ -f $BLACKLIST_FILE_AUR ]]; then
		# If the blacklist file exists and it was last modified one
		#+ day ago or less, do nothing
		[[ $(($(/usr/bin/date "+%s") -  \
		$(/usr/bin/stat -c "%Y" "$BLACKLIST_FILE_AUR"))) \
		-le 86400 ]] &&	return
	fi

	echo -ne "${blue}::$nc$bold Downloading packages blacklist" \
			 "(AUR)... $nc"

	if /usr/bin/curl -s "$BLACKLIST_SOURCE_AUR" \
	| /usr/bin/sed 's/  //g' \
	| /usr/bin/sudo -u "$user" /usr/bin/tee "$BLACKLIST_FILE_AUR" \
	1> /dev/null; then

		echo -e "${green}OK$nc"

	else
#		echoerr "${ME,,}: Error downloading file"
		exit $EXIT_FAILURE
	fi
}

################################

function extra_alternatives ()
{
	local alternative_b=""
	declare -r pkg="$1"

	case $pkg in

		firefox|"firefox-dev"*|"firefox-i18n"*\
		|"firefox-beta"*|opera|chromium|"chromium-browser"*\
		|"google-chrome"*|vivaldi|falkon|seamonkey)
			alternative_b="icecat, iceweasel"
		;;

		"virtualbox"*|vmware-workstation) alternative_b="qemu" ;;

		"acroread"*|foxitreader) alternative_b="mupdf-gl" ;;

		dropbox) alternative_b="nextcloud" ;;

		atom|electron) alternative_b="eclipse, geany" ;;

		"nvidia"*) alternative_b="xf86-video-nouveau" ;;

		wps-office) alternative_b="libreoffice-fresh" ;;

		acetoneiso2) alternative_b="brasero, graveman, simpleburn" ;;

		clonezilla) alternative_b="mondo, partclone, partimage" ;;

		krusader) alternative_b="mc (from [libre])" ;;

	esac

	echo "$alternative_b"
}

################################

function check_free ()
{
	# Check if called from the command line, namely, as '-f pkgs(s)'
	local external=0
	[[ -n $1 ]] && external=1

	[[ ${#PKGS[*]} -eq 0 ]] && return

	local pkgs_counter=${#PKGS[*]} repo="" pkg="" blacklisted="" \
	alternative="" description="" aur=0 source=""

	if [[ $external -eq 0 ]]; then
		echo -e "${blue}::$nc$bold Checking packages against the" \
				"blacklist... $nc"
	fi

	for (( i=0;i<${#PKGS[*]};i++ )); do

		repo=""; pkg=""; aur=0
		# If repo/pkg get the two values
		if [[ ${PKGS[$i]} == *"/"* ]]; then
			repo=${PKGS[$i]%%/*}
			pkg=${PKGS[$i]##*/}
		else
			pkg=${PKGS[$i]}
		fi

		# If pkg-version, get pkg name
		if [[ $pkg == *">"* || $pkg == *"<"* ]]; then
			case $pkg in
				*">"*) pkg="${pkg%%>*}" ;;
				*"<"*) pkg="${pkg%%<*}" ;;
			esac
		fi

		if [[ -n $repo ]]; then
			case $repo in

				# If $repo is some of the Parabola's repos, skip the
				#+ test, since $pkg is supposed to be free
				'libre'|'libre-multilib'|'kernels'|'pcr'|'cross'\
				|'nonprism'|'libre-testing'|'libre-multilib-testing'\
				|'pcr-testing'|'nonprism-testing')
					continue
				;;

				# If not in Parabola's repos, check it against the
				#+ blacklist
				*) ;;
			esac
		fi

		# Check if $pkg is blacklisted
		blacklisted="$(/usr/bin/grep "^${pkg}:" "$BLACKLIST_FILE" \
		2>/dev/null)"

		# If the package is not blacklisted, and if some unofficial
		#+ repo is enabled, check the AUR blacklist as well
		if [[ -z $blacklisted && $unofficial_repos -eq 1 ]]; then
			blacklisted="$(/usr/bin/grep "^${pkg}:" \
			"$BLACKLIST_FILE_AUR" 2>/dev/null)"
			aur=1
		fi

		if [[ -n $blacklisted ]]; then

			# If blacklisted, get description and alternative pkg, if any
			description="$(echo "$blacklisted" | /usr/bin/cut -d":" -f5)"
			alternative="$(echo "$blacklisted" \
			| /usr/bin/cut -d":" -f2)"

			# Parabola's blacklists lack alternative packages for non-free
			#+ soft that indeed has an alternative libre version. Here I add
			#+ a few of them for some popular packages
			if [[ -z $alternative ]]; then
				alternative="$(extra_alternatives "$pkg")"
			fi

			[[ aur -eq 0 ]] && source="official" || source="AUR"

			echo -e "$nc$bold'$pkg'$nc ($source) is a ${red}non-free$nc" \
					"package\n$nc${bold}Description${nc}:" \
					"$description\n$nc${bold}Alternative" \
					"package${nc}: $alternative"

			[[ $external -eq 1 ]] && echo ""

			# Ask only if not called via -f
			if [[ $external -eq 0 ]]; then
				local answer="." msg=""
				msg=$(echo -e "${blue}::$nc$bold Do you want to install" \
					  "'${PKGS[$i]}' anyway? [y/N]$nc ")

				while ! [[ $answer =~ ^(y|Y|n|N|)$ ]]; do
					read -rp "$msg" answer
				done

				case $answer in

					""|n|N)
						PKGS[$i]=""
						(( pkgs_counter-- ))
					;;

					y|Y) ;;
				esac
			fi

		else
			# Only if called via -f
			if [[ $external -eq 1 ]]; then
				echo -e "$nc${bold}'${PKGS[$i]}'$nc is ${green}not" \
						"blacklisted$nc"
			fi
		fi
	done

	[[ $external -eq 1 ]] && exit $EXIT_SUCCESS

	# If no pkg left after this check, just exit
	[[ $pkgs_counter -eq 0 ]] && exit $EXIT_SUCCESS

	# If no blacklisted packages found, $blacklisted will be emtpy
	if [[ -z $blacklisted ]]; then
		echo -e "${green} ->$nc No blacklisted packages found"
	fi
}

################################

function list_rules ()
{
	local rules=() rule=""

	rules=( $(/usr/bin/grep -v "^$\|^#" "$RULES_FILE" 2>/dev/null) )

	if [[ ${#rules[*]} -gt 100 ]]; then
		for rule in ${rules[*]}; do
			echo -e "$nc${bold}${rule%%/*}/${green}${rule##*/}$nc"
		done
	else
		echo -e "${ME,,}: No rules found (use '${ME,,} -a repo/pkg' to" \
				"add new rules)"
	fi
}

################################

function print_version ()
{
	printf "%-23s$ME v%s (%s, by %s)\n%-23sLicense: \
%s\n%-23sWebsite: %s\n" "" "$VERSION" "$DATE" \
"$AUTHOR" "" "$LICENSE" "" "$WEBSITE"

	/usr/bin/"$PACMAN" --version || exit $EXIT_FAILURE
}

################################

function check_added_functions ()
{
	case "$2" in

		# Modified version of pacman help (A)
		-h|--help)
			case "$1" in

				-f|--check-free) help "checkfree" ;;

				-L|--add-libre) help "addlibre" ;;

				-a|--add-rules) help "addrules" ;;

				-l|--list-rules) help "listrules" ;;

				-r|--list-repos) help "listrepos" ;;

				-u|--upgrademe) help "upgrademe" ;;

				*) /usr/bin/"$PACMAN" "$1" --help ;;
			esac

			exit $EXIT_SUCCESS ;;
	esac

	case "$1" in

		# Modified version of pacman help (B)
		"")
			echoerr "${ME,,}: No operation specified (try '${ME,,} --help')"
			exit $EXIT_FAILURE
		;;

		-h|--help)
			help "help"
			exit $EXIT_SUCCESS
		;;

		-V|--version)
			print_version
			exit $EXIT_SUCCESS
		;;

		# Added functions
		-f|--check-free)

			download_blacklist
			download_blacklist_aur

			# If no package specified, check the entire system
			if [[ -z $2 ]]; then
				check_sys_free
			# Otherwise, check only specified packages
			else
				unofficial_repos=1
				check_free "external"
			fi

			exit $EXIT_SUCCESS
		;;

		-l|--list-rules)
			list_rules
			exit $EXIT_SUCCESS
		;;

		-a|--add-rules)
			shift
			add_rules "$@"
			exit $EXIT_SUCCESS
		;;

		-L|--add-libre)
			add_libre_repos
			exit $EXIT_SUCCESS
		;;

		-r|--list-repos)
			shift
			list_repos "$@"
			exit $EXIT_SUCCESS
		;;

		-u|--upgrademe)
			upgrade_me
			exit $EXIT_SUCCESS
		;;
	esac
}

################################

function upgrade_me ()
{
	if ! [[ $(type -P /usr/bin/vercmp) ]]; then
		echoerr "${ME,,}: 'vercmp': Command not found"
		exit $EXIT_FAILURE
	fi

	declare -r RAW_URL="https://raw.githubusercontent.com/leo-arch/pacfree/master/pacfree"
	local upstream_version=""

	upstream_version="$(/usr/bin/curl -s "$RAW_URL" \
	| /usr/bin/grep ^"VERSION=" | /usr/bin/cut -d'=' -f2 \
	| /usr/bin/sed 's/"//g')"

	if [[ -z $upstream_version ]]; then
		echoerr "${ME,,}: Could not connect to server. Try again or visit" \
		"$WEBSITE"
		exit $EXIT_FAILURE
	fi

	if [[ $(/usr/bin/vercmp "$upstream_version" "$VERSION") -gt 0 ]]; then
		echo "${ME,,}: New version available ($upstream_version)"
	else
		echo "$ME ($VERSION) is up to date"
	fi
}

################################

function list_repos ()
{
	declare -r PACMAN_CONF_FILE="/etc/pacman.conf"

	if ! [[ -f $PACMAN_CONF_FILE ]]; then
		echoerr "${ME,,}: ${PACMAN_CONF_FILE}: No such file or" \
				"directory"
		exit $EXIT_FAILURE
	fi

	if [[ -n "$1" ]]; then
		for i in "$@"; do
			if /usr/bin/grep -q "^\[${i}\]" "$PACMAN_CONF_FILE"; then
				echo -e "${green}[+]$nc [${i}]: Found"
			else
				echo -e "${red}[-]$nc [${i}]: No such repository"
			fi
		done
	else
		/usr/bin/grep "^\[.*\]" "$PACMAN_CONF_FILE" \
		| /usr/bin/grep -v "options" | /usr/bin/tr -d "\[\]"
		# Or just '/usr/bin/pacman-conf -l'
	fi
}

################################

function add_rules ()
{
	if [[ -z $1 ]]; then
		echoerr "${ME,,}: No rule specfied (try '${ME,,} -a --help')"
		exit $EXIT_FAILURE
	fi

	local repo="" rule=""

	for rule in "$@"; do
		repo=""
		if [[ $rule == *"/"* ]]; then

			repo=${rule%%/*}

			if ! [[ $(/usr/bin/pacman-conf -r "$repo" \
			2>/dev/null) ]]; then
				echoerr "${ME,,}: '${repo}': No such repository"
				continue
			fi
		else
			echoerr "${ME,,}: '${rule}': A repository must be" \
					"specified. Example: 'repo/${rule}'"
			continue
		fi

		if ! /usr/bin/grep -q "$rule" "$RULES_FILE"; then
			echo "$rule" | /usr/bin/sudo -u "$user" /usr/bin/tee -a \
			"$RULES_FILE" 1>/dev/null || exit $EXIT_FAILURE

			echo -e "${green}[+]$nc '${rule}': New rule successfully" \
					"added"
		else
			echoerr "${ME,,}: '${rule}': Rule already exists"
			continue
		fi
	done
}

################################

function print_logs ()
{
	declare -r LOG_FILE="/var/log/pacman.log"

	if [[ -z $1 ]]; then
		if ! /usr/bin/cat "$LOG_FILE"; then
			exit $EXIT_FAILURE
		fi

	else
		local args=() pkgs="" grep_color=""
		args=( "$@" )
		for (( i=0;i<${#args[*]};i++)); do
			[[ $i -eq 0 ]] && pkgs="${args[$i]}" && continue
			[[ ${args[$i]} == "-"* ]] && continue
			pkgs="${pkgs}\|${args[$i]}"
		done

		if [[ $color_ok -eq 1 ]]; then
			grep_color="--color=always"
		else
			grep_color="--color=never"
		fi

		if ! /usr/bin/grep "$grep_color" "$pkgs" "$LOG_FILE"; then
			exit $EXIT_FAILURE
		fi
	fi
}

################################

function parse_arguments ()
{
	local sync_index=-1

	# If color is explicitly disabled in command line,
	#+ overwrite the config file value.
	if [[ ${p[*]} == *"--color=never"* ]]; then
		yellow=""; green=""; red=""; blue=""; bold=""; nc=""
		pacman_color="--color=never"; color_ok=0
	fi

	# Process arguments
	for (( i=0;i<${#p[*]};i++ )); do

		case ${p[$i]} in

			# Allow some APT/DNF syntax for users coming from
			#+ Debian/RedHat based systems.
			install) p[$i]="-Syu" ;;
			install-local) p[$i]="-U" ;;
			remove) p[$i]="-Rns" ;;
			update|refresh) p[$i]="-Sy" ;;
			upgrade|sysupgrade) p[$i]="-Syu" ;;
			search) p[$i]="-Ss" ;;
			list-installed) p[$i]="-Qe" ;;
			list-installed-native) p[$i]="-Qen" ;;
			list-installed-foreign) p[$i]="-Qem" ;;
			list-installed-deps) p[$i]="-Qd" ;;
			info) p[$i]="-Qi" ;;
			info-remote) p[$i]="-Si" ;;
			list-files) p[$i]="-Ql" ;;
			provides) p[$i]="-Qo" ;;
			provides-remote) p[$i]="-F" ;;
			check) p[$i]="-Qk" ;;
			clean) p[$i]="-Sc" ;;
			clean-all) p[$i]="-Scc" ;;
			download) p[$i]="-Sw" ;;

			check-free)
				download_blacklist
				download_blacklist_aur
				check_sys_free
				exit $EXIT_SUCCESS
			;;

			list-updates)
				if [[ $(type -P /usr/bin/checkupdates) ]]; then

					echo -e "${blue}::$nc$bold Checking available" \
							"upgrades... $nc"
					/usr/bin/checkupdates || exit $EXIT_FAILURE
				else
					local options="--color=auto"
					[[ $color_ok -eq 0 ]] && options="--color=never"
					/usr/bin/sudo /usr/bin/pacman "$options" -Sy \
					|| exit $EXIT_FAILURE

					echo -e "${blue}::$nc$bold Available" \
							"upgrades: $nc"
					/usr/bin/pacman "$options" -Qu \
					|| exit $EXIT_FAILURE
				fi

				exit $EXIT_SUCCESS
			;;

			list-repos)
				list_repos ${p[*]:1}
				exit $EXIT_SUCCESS
			;;
			help)
				help "help"
				exit $EXIT_SUCCESS
			;;
			version)
				print_version
				exit $EXIT_SUCCESS
			;;
			history)
				print_logs ${p[*]:1}
				exit $EXIT_SUCCESS
			;;
		esac

		# Use a second case statement to be able to catch the string
		#+ (possibily) modified by the previous case statement
		case ${p[$i]} in

			# Catch sync, refresh (-y) and sysupgrade (-u) options

			# Increment do_update to intercept -yy
			--refresh|-y) (( do_update++ )) ;;

			--sysupgrade|-u) do_sysupgrade=1 ;;

			"-S"*)
				sync_value=${p[$i]}
				sync_index=$i

				if [[ $sync_value == *'y'* ]]; then
					local res="${sync_value//[^y]}"
					do_update=$((do_update+${#res}))
				fi

				[[ $sync_value == *'u'* ]] && do_sysupgrade=1
			;;

			--sync)
				sync_value="--sync"
				sync_index=$i
			;;

			# If not a supported function, warn and exit
			--ignore|--ignoregroup)
				echoerr "${ME,,}: The --ignore and --ignoregroup" \
						"directives are not supported. You still" \
						"can use pacman configuration file" \
						"(/etc/pacman.conf) instead."
				exit $EXIT_FAILURE
			;;
		esac

	done

	if [[ -z $sync_value ]]; then
		no_install=1

	# Check non-install SHORT suboptions (c,g,h,i,l,s,w,p) for --sync.
	# None of these sync suboptions are intended for software
	#+ installation. So, if some of them is found in the sync string,
	#+ set $no_install to 1, so that check_free() and check_rules(),
	#+ only valid for package installation, won't be executed.
	#+ Drawback: This might break things if $PACMAN is not pacman or
	#+ powerpill.
	elif [[ $sync_value == "-S"* && $(echo "$sync_value" \
	| /usr/bin/grep "[c,g,h,i,l,s,w,p]") ]]; then
		no_install=1
	fi

	for (( i=0;i<${#p[*]};i++ )); do

		[[ $i -eq $sync_index ]] && continue

		# Check non-install LONG suboptions for --sync.
		if [[ -n $sync_value ]]; then
			case ${p[$i]} in
				--print|--clean|--groups|--info|--list|--search\
				|--downloadonly|--help)
					no_install=1
				;;
			esac
		fi

		# Whatever is a valid package name goes to PKGS. Everything
		#+ else goes to OPTS
		if [[ ${p[$i]} == '-'* ]]; then
			OPTS[${#OPTS[*]}]=${p[$i]}
		else
			if valid_pkg_name "${p[$i]}" -eq 0; then
				PKGS[${#PKGS[*]}]=${p[$i]}
			else
				OPTS[${#OPTS[*]}]=${p[$i]}
			fi
		fi

	done
}

################################

function check_rules ()
{
	[[ ${#PKGS[*]} -eq 0 ]] && return

	local rules=() RULED_PKGS=() pkg_name="" pkg_version=""

	### LOAD REPO RULES ###

	rules=( $(/usr/bin/grep -v "^$\|^#" "$RULES_FILE" 2>/dev/null) )

	echo -e "${blue}::$nc$bold Checking packages against rules...$nc "

	if [[ ${#rules[*]} -eq 0 ]]; then
		echo -e "$yellow ->$nc No rules defined"
		return
	fi

	### CHECK PKGS AGAINST RULES ###

	for (( i=0;i<${#PKGS[*]};i++ )); do

		pkg_name=""; pkg_version=""

		# If repo was already specified in command line (repo/pkg),
		#+ skip the rules test
		if [[ ${PKGS[$i]} == *"/"* ]]; then
			continue
		fi

		pkg_name=${PKGS[$i]}

		# Get package name from version expressions
		if [[ ${PKGS[$i]} == *"<"* || ${PKGS[$i]} == *">"* ]]; then
			case ${PKGS[$i]} in
				*"<"*)
					pkg_name="${PKGS[$i]%%<*}"
					pkg_version="<${PKGS[$i]##*<}"
				;;
				*">"*)
					pkg_name="${PKGS[$i]%%>*}"
					pkg_version=">${PKGS[$i]##*>}"
				;;
			esac
		fi

		for (( j=0;j<${#rules[*]};j++ )); do
			if [[ $pkg_name == "${rules[$j]##*/}" ]]; then

				if [[ -n $pkg_version ]]; then
					PKGS[$i]="${rules[$j]}$pkg_version"
					RULED_PKGS[${#RULED_PKGS[*]}]="${rules[$j]}$pkg_version"
				else
					PKGS[$i]=${rules[$j]}
					RULED_PKGS[${#RULED_PKGS[*]}]=${rules[$j]}
				fi

				break
			fi
		done
	done

	if [[ ${#RULED_PKGS[*]} -gt 0 ]]; then
		echo -e "${green} ->$nc Ruled packages found:"
		for (( i=0;i<${#RULED_PKGS[*]};i++ )); do
			echo " $((i+1))) ${RULED_PKGS[$i]}"
		done
	else
		echo -e "${green} ->$nc No ruled packages found"
	fi
}

################################

function check_updates ()
# The main trick of this function is to grab all packages to be
#+ upgraded to be later checked against the rules list and finally
#+ installed via the -S option.
{
	# Check sync_value looking for (y,--refresh) and
	#+ (u,--sysupgrade)

	[[ -z $sync_value ]] && return

	local tmp=""

	### UPDATE/REFRESH ###

	# If refresh, well, refresh the database
	if [[ $do_update -gt 0 ]]; then

		# If -S, remove '-y' from sync options
		# We must also remove -u, if there, since we don't want to
		#+ upgrade the system now
		if [[ $sync_value == "-S"* && $sync_value == *'y'* ]]; then
			tmp="${sync_value//[y,u]}"
			sync_value="$tmp"
		fi

		# If --sync (or -S --opts), remove "--refresh, -y" and
		#+ "--sysupgrade, -u" from the OPTS array
		OPTS=( "${OPTS[*]//--refresh}" )
		OPTS=( "${OPTS[*]//-y}" )
		OPTS=( "${OPTS[*]//--sysupgrade}" )
		OPTS=( "${OPTS[*]//-u}" )

		if [[ $do_update -gt 1 ]]; then
			/usr/bin/pacman $pacman_color ${OPTS[*]} "$sync_value" \
			-yy || exit $EXIT_FAILURE
		else
			/usr/bin/pacman $pacman_color ${OPTS[*]} "$sync_value" \
			-y || exit $EXIT_FAILURE
		fi
	fi

	### SYSTEM UPGRADE ###

	if [[ $do_sysupgrade -eq 0 ]]; then
		# If no sysupgrade and no packages to be installed (-Sy),
		#+ there is nothing else to do

		if [[ ${#PKGS[*]} -eq 0 \
		&& (${#sync_value} -lt 3 || ${OPTS[*]} != *"--clean"*) ]]; then
			exit $EXIT_SUCCESS

		# If no sysupgrade but there are packages to install
		#+ (-Sy pkgs(s)), return to continue performing checks
		else
			return
		fi
	fi

	# At this point, we know the user requested a system upgrade (but we
	#+ stil don't know if there are actually available upgrades)

	# Remove 'u' from sync options
	if [[ $sync_value == "-S"* && $sync_value == *"u"* ]]; then
		tmp="${sync_value//u}"
		sync_value="$tmp"
	fi

	OPTS=( "${OPTS[*]//--sysupgrade}" )
	OPTS=( "${OPTS[*]//-u}" )

	# Remove leading, trailing, and double spaces from OPTS
	OPTS=( "${OPTS[*]##*( )}" )
	OPTS=( "$(echo "${OPTS[*]%%*( )}" | /usr/bin/tr -s ' ')" )

	# If no update (only upgrade), that is, if -Su, update anyway
	if [[ $do_update -eq 0 ]]; then
		# Get available upgrades (update the database)
		/usr/bin/pacman $pacman_color ${OPTS[*]} "$sync_value" -y \
		|| exit $EXIT_FAILURE
	fi

	# Get pkgs to be upgraded
	local ups=()
	ups=( $(/usr/bin/pacman -Qu | /usr/bin/grep -v \
	"\[ignored\]" | /usr/bin/awk '{print $1}') )

	# If no upgrades...
	if [[ ${#ups[*]} -eq 0 ]]; then
		# and no packages to be installed, exit
		if [[ ${#PKGS[*]} -eq 0 ]]; then
			echo "There is nothing to do"
			exit $EXIT_SUCCESS
		else
			if [[ $do_sysupgrade -eq 1 ]]; then
				echo -e "${green} ->$nc$bold There are no available" \
						"upgrades$nc"
			fi
			return
		fi
	fi

	# At this point, we know there are upgrades

	# If only upgrading (no pkgs to install), set the only_upgrade flag to 1,
	#+ so that check_free() won't be executed
	[[ ${#PKGS[*]} -eq 0 ]] && only_upgrade=1

	# Append packages to be upgraded to the PKGS array
	for up in ${ups[*]}; do
		PKGS[${#PKGS[*]}]="$up"
	done

	# And finally, list available upgrades
	echo -e "${blue}::$nc$bold Available upgrades:$nc "
	/usr/bin/pacman $pacman_color -Qu || exit $EXIT_FAILURE
}

################################

function check_config ()
{
	# If pacman is not installed, this program is useless
	if ! [[ $(type -P /usr/bin/pacman) ]]; then
		echoerr "${ME,,}: pacman: Command not found"
		exit $EXIT_FAILURE
	fi

	[[ $SUDO_USER ]] && user=$SUDO_USER || user=$USER
	if [[ -z $user ]]; then
		echoerr "${ME,,}: Unable to get current username"
		exit $EXIT_FAILURE
	fi

	### GENERATE CONFIG FILES AND DIRECTORIES ###

	if [[ $user == "root" ]]; then
		CONFIG_DIR="/root/.config/${ME,,}"
	else
		CONFIG_DIR="/home/$user/.config/${ME,,}"
	fi

	CONFIG_FILE="$CONFIG_DIR/${ME,,}.conf"

	RULES_FILE="$CONFIG_DIR/rules.conf"

	if ! [[ -d $CONFIG_DIR ]]; then
		/usr/bin/sudo -u "$user" /usr/bin/mkdir -pm 700 "$CONFIG_DIR" \
		|| exit $EXIT_FAILURE
	fi

	if ! [[ -f $CONFIG_FILE ]]; then
		echo -e "# $ME configuration file

# If set to false, remove packages with trademarking and merely
# technical issues from the blacklist
full_blacklist=false

# Define your package manager, say 'pacman' or 'powerpill' or 'yay'
pac_man=pacman

# Colorize output
color=true

# Enable or disable $ME checks for packages. Though disabling both
# checks would make $ME useless, it might be usefull in some cases
check_rules=true
check_free=true
" | /usr/bin/sudo -u "$user" /usr/bin/tee "$CONFIG_FILE" 1>/dev/null \
|| exit $EXIT_FAILURE

	/usr/bin/chmod 600 "$CONFIG_FILE"

	fi

	if ! [[ -f $RULES_FILE ]]; then
		echo "# Repository rules for $ME

# Add here repository rules for packages, one per line, in the
# form 'repo/pkg' (blank and commented lines are ommited). Packages
# listed here will always be installed/upgraded from the specified
# repository (disregarding its place in the pacman configuration file).
# Example:
# core/filesystem
# libre/licenses
" | /usr/bin/sudo -u "$user" /usr/bin/tee "$RULES_FILE" 1>/dev/null \
|| exit $EXIT_FAILURE

	/usr/bin/chmod 600 "$RULES_FILE"

	fi

	### READ THE CONFIG FILE ###

	local full_bl_value="" color="" rules_value="" free_value=""

	full_bl_value="$(/usr/bin/grep "^full_blacklist=" \
	"$CONFIG_FILE" | /usr/bin/cut -d"=" -f2)"

	case $full_bl_value in
		true) full_blacklist=1 ;;
		false) full_blacklist=0 ;;
		*) full_blacklist=0 ;; # Default value
	esac

	PACMAN="$(/usr/bin/grep "^pac_man=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	if [[ -z $PACMAN ]]; then
		PACMAN="pacman"
	elif ! [[ $(type -P /usr/bin/"$PACMAN") ]]; then
		echoerr	"${ME,,}: ${PACMAN}: Command not found"
		exit $EXIT_FAILURE
	fi

	color="$(/usr/bin/grep "^color=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	case $color in
		true) color_ok=1 ;;
		false) color_ok=0 ;;
		*) color_ok=1 ;;
	esac

	if [[ $color_ok -eq 0 ]]; then
		yellow=""; green=""; red=""; blue=""; bold=""; nc=""

		# Disable color for /usr/bin/pacman as well
		pacman_color="--color=never"
	fi

	rules_value="$(/usr/bin/grep "^check_rules=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	case $rules_value in
		true) rules_ok=1 ;;
		false) rules_ok=0 ;;
		*) rules_ok=1 ;;
	esac

	free_value="$(/usr/bin/grep "^check_free=" "$CONFIG_FILE" \
	| /usr/bin/cut -d"=" -f2)"

	case $free_value in
		true) free_ok=1 ;;
		false) free_ok=0 ;;
		*) free_ok=1 ;;
	esac
}

################################

function valid_pkg_name ()
{
# From the Wiki:
# "Package names can contain only alphanumeric characters and any
#+ of @ . _ + -
#+ Names are not allowed to start with hyphens or dots. All letters
#+ should be lowercase."

	local pkg_name="$1" res="" tmp=""

	# At most, a package expression could contain 1 slash, like in
	#+ "repo/pkg". If more than one, it's not a valid expression
	res=${pkg_name//[^\/]}
	[[ ${#res} -gt 1 ]] && return $EXIT_FAILURE

	case $pkg_name in

		# Get pkg name in version expressions: "foo>1.2.3"
		*'<'*)
			tmp="${pkg_name%%<*}"
			pkg_name="$tmp"
		;;

		*'>'*)
			tmp="${pkg_name%%>*}"
			pkg_name="$tmp"
		;;

		# No valid package expression ends or starts with a slash.
		#+ If there is a slash, it should be in the middle, like
		#+ "repo/pkg"
		'/'*|*'/') return $EXIT_FAILURE ;;
	esac

	# Get pkg name in repo expressions: "repo/pkg"
	if [[ $pkg_name == *'/'* ]]; then

		# If there is a slash in the middle of the string, check
		#+ it is not a filename
		if [[ -e "$pkg_name" ]]; then
			return $EXIT_FAILURE

		# If not a filename, take whatever comes after the slash
		#+ as the package name
		else
			tmp="${pkg_name##*/}"
			pkg_name="$tmp"
		fi
	fi

	[[ -z "$pkg_name" ]] && return $EXIT_FAILURE

	# Now perform the checks for package names validity

	case $pkg_name in
		# Exclude strings only valid for --color and --architecture
		#+ options
		auto|i[0-6]86|pentium4|x86_64|any|always|never)
			return $EXIT_FAILURE
		;;

		# If it starts with a hyphen or a dot, it's not a valid
		#+ package name
		'-'*|'.'*) return $EXIT_FAILURE ;;
	esac

	# Exclude valid pkg name chars from pkg_name. If something remains,
	#+ it's not a valid package name
	if [[ $(echo "$pkg_name" \
	| /usr/bin/sed 's/[a-z0-9]\|[,@+-./]//g') ]]; then
		return $EXIT_FAILURE
	else
		return $EXIT_SUCCESS
	fi
}

################################

function check_unofficial_repos ()
{
	# Remove official repos from the repos list. If something remains,
	#+ it's unofficial
	if /usr/bin/grep "^\[" /etc/pacman.conf \
	| /usr/bin/grep -qv "options\|core\|extra\|community*\|multilib*\|testing\|gnome-unstable\|kde-unstable"; then
		unofficial_repos=1

	# Pacman wrappers like yay or trizen can install packages from the
	#+ AUR, which, of course, is unofficial.
	elif [[ $PACMAN != "pacman" && $PACMAN != "powerpill" ]]; then
		unofficial_repos=1
	fi
}

########################################################################

						#####################
						#       MAIN        #
						#####################

########################################################################

function main ()
{
	p=( "$@" ) # Command line arguments

	### INTERNAL GLOBAL VARIABLES ###

	PKGS=() # List of packages to operate on
	OPTS=() # Everything that is not a package (except the sync string)
	user="" # User running the program
	sync_value="" # Sync string. Ex: -Syu or --sync
	# Should we install/upgrade some package? If not, check_free()
	#+ and check_rules() won't be executed
	no_install=0
	# If only upgrading, that is, if not installing any extra package,
	#+ we should not run check_free()
	only_upgrade=0
	# Catch "-y,--refresh" and "-u,--sysupgrade" options
	do_update=0
	do_sysupgrade=0
	# Is the user using some unofficial repo or some package manager
	#+ able to install packages from the AUR? In this case, we should
	#+ use the AUR blacklist as well
	unofficial_repos=0

	## Config file options ##

	# Should we use the complete blacklist or a trimmed down
	#+ version without packages marked as non-free merely because
	#+ of branding and technical issues?
	full_blacklist=0

	color_ok=1 # We colorize output by default
	# The "auto" value for --color makes pacman to enable color only
	#+ when outputting onto a tty
	pacman_color="--color=auto"

	rules_ok=1 # Should we perform the rules check?
	free_ok=1 # Should we perform the free package check?

	### GET/CREATE CONFIGURATION DIRECTORIES AND FILES ###
	check_config

	### GET OPTIONS, SYNC VALUE, AND PKGS TO BE INSTALLED
	#+ FROM INPUT ###
	# Pkgs to be installed are added to PKGS
	parse_arguments

	### Check for added functions: repo rules stuff, modified help,
	#+ and libre repositories ###
	check_added_functions ${p[*]}

	### DOWNLOAD THE BLACKLISTS ###
	download_blacklist
	check_unofficial_repos
	[[ $unofficial_repos -eq 1 ]] && download_blacklist_aur

	# If no operation is specified, but only package(s), -Syu
	#+ is assumed
	if [[ ${#OPTS[*]} -eq 0 && -z $sync_value ]]; then
		sync_value="-Syu"
		no_install=0
	fi

	# This block is only for my personal configuration. You can
	#+ comment it if you like. However, it won't do anything if
	#+ /tmp/updates doesn't exist. If by chance it exists, this
	#+ block only writes a zero to the file.
	if [[ $do_sysupgrade -eq 1 && -f /tmp/updates ]]; then
		echo "0" | /usr/bin/sudo -u "$user" \
		/usr/bin/tee /tmp/updates 1>/dev/null
	fi

	### CHECK FOR UPDATES ###
	# Pkgs to be upgraded, if any, are added to PKGS
	if [[ $do_update -gt 0 || $do_sysupgrade -eq 1 ]]; then
		check_updates
	fi

	# Remove duplicates, just in case
	local tmp=()
	tmp=( $(for i in ${PKGS[*]}; do echo "$i"; done \
	| /usr/bin/sort -u) )
	PKGS=( ${tmp[*]} )
	unset tmp

	# $no_install was set above, in parse_arguments()
	# $no_install includes both upgrades and new packages
	if [[ $no_install -eq 0 ]]; then
		### CHECK PKGS AGAINST REPO RULES ###
		# If some rule is found for a package, the package name in
		#+ PKGS is replaced by the rule (repo/pkg)
		[[ $rules_ok -eq 1 ]] && check_rules

		### CHECK PACKAGES AGAINST THE BLACKLIST ###
		# Non-free/allowed pkgs are removed from PKGS
		if [[ $free_ok -eq 1 && $only_upgrade -eq 0 ]]; then
			check_free
		fi
	fi

	### FIRE UP THE PACMAN ###

	if [[ $do_sysupgrade -eq 1 ]]; then
		if [[ $only_upgrade -eq 1 ]]; then
			echo -e "${blue}::$nc$bold Starting full system" \
					"upgrade...$nc"
		else
			echo -e "${blue}::$nc$bold Starting full system" \
					"upgrade and installing new packages...$nc"
		fi
	fi

	/usr/bin/"$PACMAN" $pacman_color ${OPTS[*]} $sync_value \
	${PKGS[*]} || exit $EXIT_FAILURE

#	echo "/usr/bin/$PACMAN $pacman_color ${OPTS[*]} $sync_value ${PKGS[*]}"
}

################################

main "$@"

exit $EXIT_SUCCESS
